#!/usr/bin/env node 
const port = 3000;
const app = require("express")();
const fetch = require('node-fetch');
const opn = require('open');
const sodium = require('tweetsodium');
const fs = require('fs');
const { exit } = require('process');
const { v4: uuidv4 } = require('uuid');
var readline = require('readline');
var stream = require('stream');
const { ADDRCONFIG } = require("dns");

const input_keys = ['github_PAT', 'tenant_id', 'subscription', 'resource_group', 'resource'];

const err_msg = "There seems to be some problem. You can do one of the following:\n1.Disable the hooks if you want to have the code to atleast pushed to GitHub. For that, go to .git/hooks folder and append .sample to the hooks file names.\n2.You can retry with the execution.";
const workflow_inputs_err_msg = "There seems to be no config.yml file. If deleted, just create a config.yml file and follow the instructions given before";
const writefile_err_msg = "We have encountered some error. Please run the git commit command again..";

var config_file_fields_errors = [];

var scopeForARM = 'https://management.azure.com//user_impersonation';
var scopeForGraph = 'offline_access%20user.read%20Directory.AccessAsUser.All';
const client_id_graph = '3c2ff05c-d8db-48bf-ac19-9b0d7294e050';
const client_id_arm = '33c31634-d8df-4199-99f6-ae4b3fef50cd';
var code;
/**
 * Change the color of text
 * @param  	{String}	text 	The text to be colored
 * @param  	{String} 	color 	The color number
 * @return 	{String}       		The colored text
 */
function textColor(text, color) { 
	return `\x1b[${color}m${text}\x1b[0m`; 
}
/**
 * Pause the execution for some time
 * @param  	{Number}	time 	The amount of time (in milliseconds)
 * @return 	{Promise}			Resolves after a certain time
 */
function waitForTime(time){
	return new Promise(resolve => {
		setTimeout(function(){
			resolve();
		}, time);
	});
}
/**
 * Get the contents of the file that was at the time of installation. This will be used when user messes the file.
 * @return 	{String}	The content of the file that was at the time of installation
 */
function getFileOriginalContent(){
	var original_content = '';
	for(var input_key of input_keys){
		original_content += input_key + ": \n";
	}
	return original_content;
}
/**
 * Read the file contents
 * @param  	{String}	file_name 	The name of the file to be read
 * @return 	{Promise}				Resolves the list of lines in the given file
 */
function getFileContent(file_name){
	try{
        return fs.readFileSync(file_name).toString().split("\n");
    }
    catch(err){
        throw "Cannot get the contents from " + file_name;
    }
}
/**
 * Creates a stream for the file content
 * @param  	{String}	file_name 	The name of the file to be read from
 * @return 	{Promise}				Resolves the stream for the file contents
 */
function createReadStream(filename){
    return new Promise((resolve, reject) => {
        const fileStream = fs.createReadStream(filename);
        fileStream.on('error', () => {
			reject("Cannot read from the file: "+filename);
		}).on('open', () => {
            resolve(fileStream);
        });
    });
}
/**
 * Check if the file contents have been messed up by the user
 * @param  	{String}	file_name 	The name of the file to be checked
 * @return 	{Boolean}				Returns the boolean value whether the file is messed or not
 */
async function checkFileContentMessed(file_name){
	try{
		var instream = await createReadStream(file_name);
		var rl = readline.createInterface({
			input: instream,
			crlfDelay: Infinity
		});
	}
	catch(err){
		throw err;
	}
	var input_number = 0;
	var file_messed_up = false;
	for await (const line of rl) {
		if(input_number === input_keys.length){
			break;
		}
		split_input = line.replace(/\s+/g, '').split(":");
		if(split_input.length > 2 || split_input[0] !== input_keys[input_number]){
			file_messed_up = true;
			config_file_fields_errors.push(input_keys[input_number]);
		}
		input_number++;
	}
	if(file_messed_up){
		throw "File has been messed up while giving inputs.";
	}
	else
		return true;
}
/**
 * Rewrite the file with some content
 * @param  	{String}	file_name 	the name of the file to be rewritten
 * @param  	{String} 	content		The content to be written
 */
async function writeFile(file_name, content){	
	try{
        fs.writeFileSync(file_name, content);
    }
    catch(err){
		throw "Cannot write to the file: " + file_name;
    }
}
/**
 * Get all the details pertaining to a user's Github account and their subscription and resource choice.
 * @param  	{String} 	file_inputs 		The input file content used for getting some required field values
 * @return 	{Promise}						Resolves an object that stores the user's' details
 */
async function getUserDetails(file_inputs){
	var userDetails = {};
	return new Promise(function(resolve) {
		const { exec } = require('child_process');
		exec('git config --list', (error, stdout, stderr) => {
			var array_stdout = stdout.split("\n");
			for(var single_info of array_stdout){
				var info_splitted = single_info.split("=");
				if(info_splitted[0] === 'user.name'){
					userDetails['username'] = info_splitted[1];
				}

				if(info_splitted[0] === 'user.email'){
					userDetails['user_email'] = info_splitted[1];
				}

				if(info_splitted[0] === 'remote.origin.url'){
					userDetails['repo_name'] = info_splitted[1].split("https://github.com/")[1].split("/")[1].split(".")[0];
				}
			}

			for(var input = 0; input < input_keys.length; input++){
				var data = file_inputs[input].replace(/\s+/g, '').split(":")[1];
				if(input_keys[input] === 'resource_group' && (data === '') || data === '<resource_group>'){
					userDetails[input_keys[input]] = 'ResGrp' + userDetails['repo_name'].replace(/[^0-9A-Z]+/gi,"");
				}
				else if(input_keys[input] === 'resource' && (data === '') || data === '<resource>'){
					userDetails[input_keys[input]] = 'Res' + userDetails['repo_name'].replace(/[^0-9A-Z]+/gi,"");
				}
				else
					userDetails[input_keys[input]] = data;
			}
			resolve(userDetails);
		});
  	});
}
/**
 * Open the Authentication URL in default browser
 * @param  	{String} 	scope 			The scopes required by the OAuth app
 * @param  	{String} 	callback 		The redirect URL for the OAuth app
 * @param  	{String} 	client_id 		Client ID of the OAuth app
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function openSignInLink(scope, callback, client_id, userDetails){
	await opn('https://login.microsoftonline.com/'+userDetails['tenant_id']+'/oauth2/v2.0/authorize?client_id='+client_id+'&response_type=code&redirect_uri='+callback+'&response_mode=query&scope='+scope+'&state=AzureShubhamLogIn');
}
/**
 * Get the redirect  URL for the OAuth process
 * @param  {String} callback 	The redirect page for the OAuth app
 * @return {Promise}			Resolves after sending the data to the redirect page
 */
async function getCallback(callback){
	return new Promise((resolve) => {
		app.get(callback, function(req, res){
			code = req.query['code'];
			res.send("You are logged in, now you can go back to your terminal!");
			resolve();
		});
	});
}
/**
 * Get the Access token for an endpoint
 * @param  	{String} 	endpoint 		The endpoint used in the OAuth process.
 * @param  	{String} 	scope 			The scopes required by the OAuth app
 * @param  	{String} 	callback 		The redirect page for the OAuth app
 * @param  	{String} 	client_id 		Client ID of the OAuth app
 * @param  	{Object} 	userDetails 	The object that stores user's information
 * @return 	{Promise}					resolves after the POST request made to obtain access token
 */
function getAccessToken(endpoint, scope, callback, client_id, userDetails){	
	
	var url = 'https://login.microsoftonline.com/'+userDetails['tenant_id']+'/oauth2/v2.0/token';
	var opts = {
		method: 'POST',
		body: 'client_id='+client_id+'&scope='+scope+'&redirect_uri='+callback+'&code='+code+'&grant_type=authorization_code',
		headers: {
			"Content-Type": "application/x-www-form-urlencoded"
        }
    };
    return new Promise(function(resolve, reject) {
		function retry(num){
			setTimeout(() => {reject('timeout')}, 15000);
			fetch(url, opts)
				.then(async res => {
					var json = await res.json();
					userDetails[endpoint] = json;
					resolve();
				})
				.catch(async error => {
					if(num === 1){
						reject(error);
					}
					else{
						await waitForTime(1000);
						retry(num-1);
					}
				});
		}
		retry(3);
    });
}
/**
 * Make a GET/PUT/POST request
 * @param  	{String} 	url 		The url for the request
 * @param  	{String} 	options 	The options associated with the request
 * @param  	{String} 	timeout		The time limit for the API Calls
 * @return 	{Promise}				Resolves the response received
 */
function makeAPICall(url, options, timeout){
    return new Promise(function(resolve, reject) {
		function retry(num){
			setTimeout(() => {reject('timeout')}, timeout);
			fetch(url, options)
				.then(async res => {
					try{
						var json = await res.json();
						resolve(json);
					}
					catch(err){
						resolve();
					}
				})
				.catch(async error => {
					if(num === 1){
						await waitForTime(1000);
						reject(error);
					}
					else{
						retry(num-1);
					}
				});
		}
		retry(3);
    });
}
/**
 * Create a new secret in User's GitHub account
 * @param  	{String} 	secret_name 					The secret name to be created
 * @param  	{Object} 	secret_value 					The value of the secret to be created
 * @param  	{Object} 	userDetails 					The object that stores user's information
 * * @param	{Object} 	repoPublicKey 					The object that stores the repository's public key
 */
async function CreateNewSecret(secret_name, secret_value, userDetails, repoPublicKey){
	
	const username = userDetails['username'];
	const user_email = userDetails['user_email'];
	const repo_name = userDetails['repo_name'];
	const key = repoPublicKey['key'];
	const messageBytes = Buffer.from(JSON.stringify(secret_value));
	const keyBytes = Buffer.from(key, 'base64');

	const encryptedBytes = sodium.seal(messageBytes, keyBytes);
	const encrypted = Buffer.from(encryptedBytes).toString('base64');
	var body = JSON.stringify({
		message: "Adding secret",
		committer: {
			name: username,
			email: user_email
		},
		encrypted_value: encrypted,
		key_id: repoPublicKey['key_id']
	});
	try{
		await makeAPICall('https://api.github.com/repos/'+username+'/'+repo_name+'/actions/secrets/'+secret_name, {
			method: 'PUT',
			json: true,
			body: body,
			headers: {
				"Content-type": "application/json",
				Authorization: `Bearer ${userDetails['github_PAT']}`
			}
		}, 30000);
	}
	catch(err){
		throw err;
	}
}
/**
 * Check if there exists an app for the SPN already created by the product in user's tenant
 * @param  	{Object} 	userDetails 	The object that stores user's information
 * @param  	{String} 	app_name 		The name of the app to be checked
 * @return 	{Boolean}					The boolean value whether the app exists or not
 */
function newAppRequired(userDetails, app_name){
	for(var application of userDetails['applications']){
		if(application['displayName'] === app_name){
			return false;
		}
	}
	return true;
}
/**
 * Authenticate the user's azure account for the Microsoft Graph endpoint
 * @param 	{Object} 	userDetails		The object that stores user's information
 */
async function OAuthGraph(userDetails){
	await openSignInLink(scopeForGraph, 'http://localhost:3000/callback', client_id_graph, userDetails);
	await getCallback('/callback');
	try{
		await getAccessToken('graph_details', scopeForGraph, 'http://localhost:3000/callback', client_id_graph, userDetails);
	}
	catch(reject){
		console.log(err_msg);
		process.exit(1);
	}
}
/**
 * Authenticate the user's azure account for the ARM endpoint
 * @param 	{Object} 	userDetails		The object that stores user's information
 */
async function OAuthARM(userDetails){
	await openSignInLink(scopeForARM, 'http://localhost:3000/callbackarm', client_id_arm, userDetails);
	await getCallback('/callbackarm');
	try{
		await getAccessToken('arm_details', scopeForARM, 'http://localhost:3000/callbackarm', client_id_arm, userDetails);
	}
	catch(reject){
		console.log(err_msg);
		process.exit(1);
	}
}
/**
 * Check if resource or resource group is present or not
 * @param  	{String}	to_be_checked 	the value is either resource_groups or resources
 * @param  	{String} 	name			the value is either resource_group or resource
 * @param  	{Object} 	userDetails 	The object that stores user's information
 * @return 	{Boolean}					Returns a boolean whether the resource or resource_group exists or not in user's tenant
 */
function checkIfExists(to_be_checked, name, userDetails){
	for(var data of userDetails[to_be_checked]){
		if(data['name'] === userDetails[name])
			return true;
	}
	return false;
}
/**
 * Get the list of avaliable locations in the user's subscription
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function getLocations(userDetails){
	userDetails['locations'] = await makeAPICall(`https://management.azure.com/subscriptions/${userDetails['subscription']}/locations?api-version=2020-01-01`, {
		method: 'GET',
		headers: {
			Authorization: `${userDetails['arm_details']['token_type']} ${userDetails['arm_details']['access_token']}`
		}
	}, 15000);
	userDetails['locations'] = userDetails['locations']['value'];
}
/**
 * Get the list of Resource Groups in the user's subscription
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function getResourceGroups(userDetails) {
	userDetails['resource_groups'] = await makeAPICall(`https://management.azure.com/subscriptions/${userDetails['subscription']}/resourcegroups?api-version=2019-10-01`, {
			method: 'GET',
			headers: {
				Authorization: `${userDetails['arm_details']['token_type']} ${userDetails['arm_details']['access_token']}`
			}
		}, 15000);
		userDetails['resource_groups'] = userDetails['resource_groups']['value'];
}
/**
 * Create a Resource Group in the user's subscription
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function createResourceGroup(userDetails){
	console.log("Creating a new Resource Group: " + userDetails['resource_group']);
	await makeAPICall(`https://management.azure.com/subscriptions/${userDetails['subscription']}/resourcegroups/${userDetails['resource_group']}?api-version=2019-10-01`, {
		method: 'PUT',
		json: true,
		body: JSON.stringify({
			"location": userDetails['locations'][0]['name'],
		}),
		headers: {
			"Content-type": "application/json",
			Authorization: `${userDetails['arm_details']['token_type']} ${userDetails['arm_details']['access_token']}`
		}
	}, 30000);
	console.log("Done!");
}
/**
 * Get the list of Resource in the user's subscription
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function getResources(userDetails){
	userDetails['resources'] = await makeAPICall("https://management.azure.com/subscriptions/"+userDetails['subscription']+"/resourceGroups/"+userDetails['resource_group']+"/resources?$filter=resourceType eq 'Microsoft.Web/sites'&api-version=2019-10-01", {
		method: 'GET',
		headers: {
			Authorization: `${userDetails['arm_details']['token_type']} ${userDetails['arm_details']['access_token']}`
		}
	}, 20000);
	userDetails['resources'] = userDetails['resources']['value'];
}
/**
 * Create a Resource in the user's subscription
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function createResource(userDetails){
	console.log("Creating a new Resource: " + userDetails['resource']);
	await makeAPICall(`https://management.azure.com/subscriptions/${userDetails['subscription']}/resourcegroups/${userDetails['resource_group']}/providers/Microsoft.Web/sites/${userDetails['resource']}?api-version=2019-08-01`, {
		method: 'PUT',
		json: true,
		body: JSON.stringify({
			"location": userDetails['locations'][0]['name'],
			"type": "Microsoft.Web/sites",
			"properties" : {}
		}),
		headers: {
			"Content-type": "application/json",
			Authorization: `${userDetails['arm_details']['token_type']} ${userDetails['arm_details']['access_token']}`
		}
	}, 50000);
	console.log('Done!');
}
/**
 * Get the list of Resource in the user's tenant
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function getApplications(userDetails){
	userDetails['applications'] = await makeAPICall('https://graph.microsoft.com/v1.0/applications', {
		method: 'GET',
		headers: {
			Authorization: `${userDetails['graph_details']['token_type']} ${userDetails['graph_details']['access_token']}`
		}
	}, 15000);
	userDetails['applications'] = userDetails['applications']['value'];
}
/**
 * Create an App in the user's tenant
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function createApp(userDetails){
	console.log("Creating an application: " + 'AppForSPN'+userDetails['resource']);
	userDetails['new_app_details'] = await makeAPICall('https://graph.microsoft.com/v1.0/applications', {
		method: 'POST',
		json: true,
		body: JSON.stringify({
			"displayName": 'AppForSPN'+userDetails['resource']
		}),
		headers: {
			"Content-Type": "application/json",
			Authorization: `${userDetails['graph_details']['token_type']} ${userDetails['graph_details']['access_token']}`
		}
	}, 30000);
	console.log("Done!");
}
/**
 * Create an SPN
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function createSPN(userDetails){
	userDetails['new_app_details']['spn_details'] = await makeAPICall('https://graph.microsoft.com/v1.0/serviceprincipals', {
		method: 'POST',
		json: true,
		body: JSON.stringify({
			"appId": userDetails['new_app_details']['appId']
		}),
		headers: {
			"Content-Type": "application/json",
			Authorization: `${userDetails['graph_details']['token_type']} ${userDetails['graph_details']['access_token']}`
		}
	}, 30000);
}
/**
 * Add a password to the applications created
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function addPassword(userDetails){
	userDetails['new_app_details']['password'] = await makeAPICall(`https://graph.microsoft.com/v1.0/applications/${userDetails['new_app_details']['id']}/addPassword`, {
		method: 'POST',
		json: true,
		body: JSON.stringify({
			"passwordCredential": {
				"displayName": "Password"+userDetails['new_app_details']['displayName']
			}
		}),
		headers: {
			"Content-Type": "application/json",
			Authorization: `${userDetails['graph_details']['token_type']} ${userDetails['graph_details']['access_token']}`
		}
	}, 30000);
}

/**
 * Get the Repository Public Key
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function getRepoPublicKey(userDetails){
	userDetails['repo_public_key'] = await makeAPICall(`https://api.github.com/repos/${userDetails['username']}/${userDetails['repo_name']}/actions/secrets/public-key`, {
		method: 'GET',
		headers: {
			Authorization: `Bearer ${userDetails['github_PAT']}`
		}
	}, 15000);
}
/**
 * Assign a resource level scope to the SPN
 * @param  	{Object} 	userDetails 	The object that stores user's information
 */
async function addRoleAssignment(userDetails){
	var guid = uuidv4();
	await makeAPICall(`https://management.azure.com/subscriptions/${userDetails['subscription']}/resourcegroups/${userDetails['resource_group']}/providers/microsoft.web/sites/${userDetails['resource']}/providers/Microsoft.Authorization/roleAssignments/${guid}?api-version=2015-07-01`,{
		method: 'PUT',
		body: JSON.stringify({
			"properties": {
				"roleDefinitionId": `/subscriptions/${userDetails['subscription']}/resourcegroups/${userDetails['resource_group']}/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c`,
				"principalId": userDetails['new_app_details']['spn_details']['id'],
				"scope": `/subscriptions/${userDetails['subscription']}/resourcegroups/${userDetails['resource_group']}/providers/microsoft.web/sites/${userDetails['resource']}`
			}
		}),
		headers: {
			"Content-type": "application/json",
			Authorization: `${userDetails['arm_details']['token_type']} ${userDetails['arm_details']['access_token']}`
		}
	}, 30000);
}

async function main(){
	var original_content = getFileOriginalContent();
	try{
		await checkFileContentMessed('config.yml');
	}
	catch(err){
		try{
			writeFile('config.yml', original_content);
		}
		catch(reject){
			console.log(writefile_err_msg);
			exit(1);
		}
		console.log("You have messed up the file. Please follow the format of giving inputs PROPERLY.\nMake sure that you have not added any extra lines or changed any field.\nFollowing fields were affected:");
		for(var error_input of config_file_fields_errors){
			console.log(error_input);
		}
		console.log("\nProgram exitted\n");
		exit(1);
	}

	var server = app.listen(port, async function () {
		console.log("Server Has Started!");
	});
	
	try{
		var file_inputs = await getFileContent('config.yml');
	}
	catch(reject){
		console.log(workflow_inputs_err_msg);
		exit(1);
	}
	
	var userDetails = await getUserDetails(file_inputs);
	await OAuthGraph(userDetails);
	await OAuthARM(userDetails);
	try{
		await getLocations(userDetails);
		await getResourceGroups(userDetails);
		
		
		if(!checkIfExists('resource_groups', 'resource_group', userDetails)){
			if(userDetails['locations'].length > 0){
				await createResourceGroup(userDetails);
			}
			else{
				console.log("There are no available locations to create a resource group in your subscription.. Exitting..");
				exit(1);
			}
		}

		await getResources(userDetails);

		if(!checkIfExists('resources', 'resource', userDetails)){
			if(userDetails['locations'].length > 0){
				await createResource(userDetails);
			}
			else{
				console.log("There are no available locations to create a resource in your subscription.. Exitting..");
				exit(1);
			}
		}
		await getApplications(userDetails);		
		if(newAppRequired(userDetails, 'AppForSPN'+userDetails['resource'])){
			await createApp(userDetails);
			await createSPN(userDetails);
			await addPassword(userDetails);

			userDetails['new_app_details']['password'] = userDetails['new_app_details']['password']['secretText'];
			await waitForTime(3000);
			var secret_value = {
				"clientId": userDetails['new_app_details']['spn_details']['appId'],
				"clientSecret": userDetails['new_app_details']['password'],
				"subscriptionId": userDetails['subscription'],
				"tenantId": userDetails['tenant_id'],
				"activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
				"resourceManagementEndpointUrl": "https://management.azure.com"
			}
			await getRepoPublicKey(userDetails);
			await CreateNewSecret('SPN_CREDENTIALS_GIT_HOOKS_DTA', secret_value, userDetails, userDetails['repo_public_key']);
			await addRoleAssignment(userDetails);	
		}
	}
	catch(reject){
		console.log(reject);
		exit(1);
	}
	console.log();
	console.log('***************************************************************************************************************************************************************');
	console.log();
	console.log(`You can have a look at the workflow runs using this link:\n\n${textColor('https://github.com/'+userDetails['username']+'/'+userDetails['repo_name']+'/actions', 95)}`);
	console.log('                                       Or                                                                          ');
	console.log('IF A WORKFLOW CREATED BY THIS PACKAGE IS BEING TRIGGERED THEN, You can run this command on your terminal to open the link in browser :'+ textColor(' node open_workflow_run', 95));
	console.log();
	console.log('***************************************************************************************************************************************************************');
	console.log();
	exit(0);

};

main();